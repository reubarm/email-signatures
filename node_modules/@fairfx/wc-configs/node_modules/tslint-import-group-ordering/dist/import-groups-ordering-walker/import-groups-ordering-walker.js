"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Lint = require("tslint");
const ts = require("typescript");
const nodes_containers_utils_1 = require("../nodes-containers/nodes-containers-utils");
const nodes_containers_1 = require("../nodes-containers");
class ImportGroupsOrderingWalker extends Lint.AbstractWalker {
    constructor() {
        super(...arguments);
        this.currentImportsGroupOrderNumber = 1;
        this.allowNextImportsGroup = true;
        this.foundUnmatchedImportDeclaration = false;
        this.possiblyMisplacedNonImportStatements = new nodes_containers_1.NodesContainer(this.getSourceFile());
    }
    walk(sourceFile) {
        for (const statement of sourceFile.statements) {
            this.checkStatement(statement);
        }
        if (this.failures.length > 0 && !this.foundUnmatchedImportDeclaration) {
            this.addFailureWithAutoFix();
        }
    }
    checkStatement(statement) {
        if (this.isStatementAfterEmptyLine(statement)) {
            this.endBlock();
        }
        if (ts.isImportDeclaration(statement)) {
            if (!this.possiblyMisplacedNonImportStatements.isEmpty()) {
                this.handleMisplacedNonImportStatements();
            }
            this.checkImportDeclaration(statement);
            this.allowNextImportsGroup = false;
        }
        else {
            this.possiblyMisplacedNonImportStatements.addNode(statement);
        }
    }
    isStatementAfterEmptyLine(statement) {
        const { sourceFile } = this;
        return /\r?\n\r?\n/.test(sourceFile.text.slice(statement.getFullStart(), statement.getStart(sourceFile)));
    }
    checkImportDeclaration(node) {
        if (!ts.isStringLiteral(node.moduleSpecifier)) {
            // NOTE: Ignore grammar error
            return;
        }
        const { matchingRules } = this.options;
        const foundMatchingRule = matchingRules.find(matchingRule => matchingRule.matches(node));
        if (!foundMatchingRule) {
            this.addFailureAtNode(node, 'The import declaration does not match any configured import groups');
            this.foundUnmatchedImportDeclaration = true;
            return;
        }
        const matchingImportsGroup = foundMatchingRule.importsGroup;
        matchingImportsGroup.nodesContainer.addNode(node);
        this.verifyImportsGroupOrder(matchingImportsGroup, node);
    }
    verifyImportsGroupOrder({ orderNumber, name }, node) {
        if (orderNumber < this.currentImportsGroupOrderNumber) {
            this.addFailureAtNode(node, `This import declaration should appear in an earlier group ("${name}", number ${orderNumber})`);
        }
        else if (orderNumber > this.currentImportsGroupOrderNumber) {
            if (!this.allowNextImportsGroup) {
                this.addFailureAtNode(node, `This import declaration should appear in a later group ("${name}", number ${orderNumber})`);
            }
            this.currentImportsGroupOrderNumber = orderNumber;
        }
    }
    endBlock() {
        this.allowNextImportsGroup = true;
    }
    handleMisplacedNonImportStatements() {
        const { pos, end } = this.possiblyMisplacedNonImportStatements.getTextRange();
        this.addFailureAt(pos, end - pos, 'Non-import statements should not appear between import groups');
        this.options.misplacedNonImportStatementsContainer.copyNodesFrom(this.possiblyMisplacedNonImportStatements);
        this.possiblyMisplacedNonImportStatements = new nodes_containers_1.NodesContainer(this.getSourceFile());
    }
    addFailureWithAutoFix() {
        const { importsGroups, misplacedNonImportStatementsContainer } = this.options;
        const allNodesContainers = [
            ...importsGroups.map(importsGroup => importsGroup.nodesContainer),
            misplacedNonImportStatementsContainer
        ];
        const { pos, end } = nodes_containers_utils_1.getBoundingTextRange(allNodesContainers);
        const orderedImportGroups = nodes_containers_utils_1.stringifyNodesContainers(allNodesContainers);
        this.addFailure(pos, end, 'Invalid import groups order', new Lint.Replacement(pos, end - pos, orderedImportGroups));
    }
}
exports.ImportGroupsOrderingWalker = ImportGroupsOrderingWalker;
